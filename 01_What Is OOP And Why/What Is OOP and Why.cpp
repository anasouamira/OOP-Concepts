// ==========================================
// üß† Object-Oriented Programming (OOP)
// ==========================================

// OOP is a programming paradigm that organizes code into objects.
// Objects are instances of classes and bundle together:
// - Data (called attributes or member variables)
// - Behavior (functions called methods or member functions)

// Key OOP Principles:

// 1. Encapsulation:
//    - Keeps data safe by wrapping it with methods in a class
//    - Only exposes controlled interfaces (getters/setters)

// 2. Abstraction:
//    - Hides internal implementation details
//    - Focuses on what an object does, not how it does it

// 3. Inheritance:
//    - Allows one class to inherit properties and methods from another
//    - Promotes code reuse

// 4. Polymorphism:
//    - Allows using the same interface with different implementations
//    - Supports dynamic method overriding (via virtual functions)

// Advantages of OOP:
// - Makes complex code easier to manage and extend
// - Encourages modular and reusable design
// - Ideal for systems involving many entities (e.g., games, simulations)

// ==========================================
// üîÅ Functional Programming (FP)
// ==========================================

// FP is a paradigm focused on pure functions and immutable data.
// Functions are treated as first-class citizens and state changes are avoided.

// Key FP Concepts:

// 1. Pure Functions:
//    - Output depends only on input
//    - No side effects (doesn‚Äôt modify external state)

// 2. Immutability:
//    - Data is not modified; instead, new data is created

// 3. Higher-Order Functions:
//    - Functions that take other functions as arguments or return them

// 4. Referential Transparency:
//    - Expressions can be replaced with their values without changing behavior

// Advantages of FP:
// - Easier to test, debug, and reason about
// - Naturally supports concurrency and parallelism
// - Suited for data transformations, calculations, and reactive systems

// ==========================================
// üÜö OOP vs FP: Conceptual Comparison
// ==========================================

// OOP:
// - Focuses on objects, state, and behaviors
// - Good for modeling real-world entities
// - Encourages design around entities and their responsibilities

// FP:
// - Focuses on functions and data transformations
// - Avoids shared mutable state
// - Encourages stateless, predictable computations

// Many modern languages (like C++, Python, JavaScript) support both OOP and FP,
// allowing you to mix both paradigms as needed based on the use case.
